# Test# 소프트웨어 공학 내용 정리

## 1. 소프트웨어 개발 개요

### 1.1. 소프트웨어 공학 소개

- Software Crisis : 1960년대 많은 소프트웨어 프로젝트가 실패
- Software Engineering : 소프트웨어의 개발, 운영 및 유지 보수에 **체계적**이고, **규율적**이고 **정략적**인 접근 방법을 적용하는 것
  - 소프트웨어 공학에 대한 공학적 접근
  - 공학접 접근 방법 : 도구, 프로세스, 방법론
- SWEBOK : Software Engineering Body Of Knowledge
  - 미국 컴퓨터 협회와 IEEE Computer Society에서 발간한 전문 소프트웨어 엔지니어가 반드시 갖추어야할 능력을 구성하는 지식 영역
  - 엔지니어링 측면 : 요구사항 , 설계 , 개발 , 테스트 , 유지보수
  - 관리 측면 : , 형상관리 , 관리, 프로세스, 툴, 방법론, 품질

### 1.2. 소프트웨어 개발 프로세스

- 소프트웨어 개발 단계 : 요구사항 -> 설계 -> 구현 -> 테스팅

### 1.3. 유지보수(Maintenance)

- 종류

  - Corrective(수정 유지보수) : 소프트웨어의 오류 수정

  - Adaptive(적응 유지보수) : 변화를 수용하도록 하는 수정

  - Perfective(완전 유지보수) : 기능개선, 성능개선, 기능추가

  - Preventive(예방 유지보수) : 오류등을 미연에 방지

- 비율

  - 50 ~ 55 : Perfective 
  - 20 ~ 25 : Adaptive
  - 20 : Corrective 
  - 5 : Preventive



## 2.SDLC

### 2.1. SDLC

- SDLC(Software Development life cycle)
  - 소프트웨어 요구사항부터 개발 운영 
- leadtime : 

### 2.2. Iron Triangle

### 2.3. Waterfall

- 특징
  - 순차적 : 이전단계 완료 후 다음 단계 수행
  - 계획 주도적
  - 단계별 산출물이 명확
  - 피드백을 줄 수 있는 기회가 한정적 : 리스크가 있음
  - 리스크는 계속해서 증가하지만 제작이 완료되어야 산출물이 나옴
  - 문제가 잘 정의되어 있고 예측가능하며 큰 변화가 없는 시스템을 개발 할 때 적용
- 불확실성
  - End Uncertainty(목적 불확실성) : 무엇을 만들지
  - Means Uncertainty(수단 불확실성) : 어떻게 만들지
  - 폭포수 모델은 End Uncertainty를 최소화 한 후 Means Uncertainty를 줄이는 방향으로 개발 진행
    - 따라서 중간에 목적 변화가 큰 개발에는 적합하지 x
- 아이언 트라이앵글로 해석
  - 고정 : Scrope
  - 변화 : Resoures , Schedule

### 2.4. RAD

- RAD(Rapid Application Development) : 사용자의 지속적 참여하에서 빠르게 애플리케이션을 개발하기 위한 개발 라이프 사이클 모델

- <img src="assets/image-20230420175404312.png" alt="image-20230420175404312" style="zoom: 33%;" />

- 특성

  - 고객참여 : 사용자의 지속적인 참여로 지속적인 피드백을 제공하여 소프트웨어를 지속적으로 개선
    - 모든 과정에서 고객이 참여
  - 신속개발 : 빠른 개발을 위해 애플리케이션 자동 생성 도구 이용
    - 기술 위험이 적고, 신속한 개발 필요시 사용
  - 짧은 주기 : 코드 재사용 및 애플리케이션 자동 생성 도구에 의한 짧은 개발주기 (60~90일)

- Waterfall 과 비교

  - 개발이 만족시까지 계속해서 진행되기 때문에 비용을 예측하기 힘듬 

  - 테스팅

    - RAD : 개발 전 과정에서 테스트 함
    - Waterfall : 개발 마지막에

  - 고수준의 기술이 필요한 소프트웨어에는 적합하지 않음

  - Not for end user : 주문한 고객이 직접사용하는지

    - 사용자가 직접 사용하는 상품이 아니면 적합하지 않음 : 페이스메이커, 자동주행

- 계속해서 애플리케이션 개발

### 2.5. Lean Startup

- 아이디어를 빠르게 제품화 시킨 후 고객의 피드백을 반영하여 지속적으로 제품 개선
  - 아이디어를 완벽한 제품으로 구현한 후 시장에 내놓는 것이 아니라 제품화 시키는 과정에서 피드백을 통해 시장이 원하는 제품을 만들겠다는 전략
- 고객이 원하지 않는 제품을 만드는것이 스타트업의 가장 큰 위협이라는 주장 하에서 제안됨
- 만들기 : 고객의 피드백을 받을만한 최소한의 제품 제작
  - MVP(Minimum Viable Product) : 최소 기능 제품
- 가설의 검증

### 2.6. Agile

- Agile : 짧은 interation 동안 제품이 나오고 그 제품을 바탕으로 피드백을 받아 다음 interation 실행
- 고객의 요구사항 우선순위에 따라 실행
- 요구사항이 완전히 작동해야함
- 반복적 점진적 개발

  - 점진적 개발 : 이전 시스템에 새로운 요구사항을 추가
  - 반복적 개발 : 이전 시스템을 한번에 완전히 변경하는것이 아닌 반복적으로 개선하고 수정
- 목적 불확실성과 수단 불확실성을 지속적으로 제거해 나감
- waterfall과 비교

  - 시간이 지날수록 고객이 만족하지 못할 리스크가 줄어들음
  - 점진적으로 고객에게 전달할 수 있는 value가 늘어남
- 방법론

  - iteration
    - 1주에서 4주로 매우 짧음
    - 분석, 설계, 구현, 테스트의 모든 과정을 수행
    - 산출물 생성
  - 일단 이터레이션에 들어가면 요구사항의 변경은 받아들이지 않음
  - 각 iteration마다 새로운 요구사항이 추가되어 개발
    - 우선순위가 높은 기능부터 구현
      - 가장 높은 비지니스 가치를 가져다 주는 요구사항의 우선순위가 높음
    - 고객의 요구사항을 탄력적으로 처리할수 있는 기회 제공
- 애자일 방법론 종류

  - XP(익스트림 프로그래밍)
  - Scrum
  - 크리스털 패밀리
  - Feature-driven development
  - Adative software development
  - 익스트림 모델링
- Agile 선언

  - 개인과의 상호작용 vs 프로세스와 도구
    - Individuals and interactions over processes and tools
  - 동작하는 소프트웨어 vs 문서
    - Working software over comprehensive documentation
  - 고객과의 관계 vs 계약관계
    - Customer collaboration over contract negotiation
  - 변화를 따르기 vs 계획을 따르기
    - Responding to change over following a plan
- Agile 원칙

  1. **최우선 가치는 소프트웨어를 일찍 그리고 지속적으로 전달해서 고객의 만족도 상승**
  2. **개발의 후반부라도 요구사항 변경을 환영**
     - 고객의 경쟁력에 도움이 되기 때문
     - 요구사항에 대한 변경을 부담스럽지 않게 하는 방법론으로서 개발자의 부담 해결 : 이터레이션
  3. **작동하는 소프트웨어를 자주 전달**
     - 2주~2개월 정도
     - 더 짧은 기간을 선호
  4. **비즈니스 쪽과 개발자는 항상 협력해야함**
     - 처음에는 부담스럽지만 결과적으로 변화에 대응하기 쉬워짐
  5. **동기가 부여된 개인을 중심으로 프로젝트를 구성하고 일을 끝내리라고 신뢰하기**
     -  개인과의 상호작용
  6. **면대면 대화 선호**
  7. **작동하는 소프트웨어를 진척의 척도로**
  8. 지속가능한 개발 : 개발에 일정한 속도
  9. 기술적 탁월성과 설계에대한 관심
  10. 단순성 : 안하는 일의 양을 최대화
  11. **자기조직적인 팀 : 스스로 계획 가능한 팀이 애자일을 잘 수행할 수 있음**
  12. **정기적으로 팀에 대한 피드백**

### 2.7. DevOps

- DebOps : 개발 팀과 운용 팀이 협력하여 비즈니스 요구에 신속하게 대응하여 소프트웨어 개발 및 배포

- 배포된 소프트웨어 운영환경에서 안정적으로 동작하도록 하여 비즈니스 가치 실현

- 데브옵스 프로세스 

  - <img src="assets/image-20230420190544506.png" alt="image-20230420190544506" style="zoom: 50%;" />
  - PLAN : 요구사항 정의
  - CODE : 구현 및 코드 저장소에 커밋
  - Build : 커밋된 코드를 검사 후 기존 코드와 통합
  - Test : 운영환경에 배포할 상태가 되어있는지 테스트
  - Release : 최종 산출물(바이너리) 관리
  - Deploy : 최종 산출물을 실제 운영 환경에 배포
  - Operate : 운영 및 데이터 수집
  - Monitor : 데이터를 모니터링해 다음 개발 계획에 대한 피드백

- 데브옵스는 하루에 몇번식 릴리스를 얻을 수 있음

- CI & CD

  - Big Bang Intergration : 코드의 통합이 프로젝트 종료 시점에 한번에 이루어짐

    - 뒤늦은 결함 발견 -> 비용증가

    - 어떤 부분에 문제가 발생했는지 알기 어려움
    - 배포가능한 소프트웨어 부재
    - 제품에 대한 자신감 결여

  - CI(Continuous Integration) : 각 개발자의 작업을 초기부터 빈번하게 검증 및 통합이 이루어 지도록 하는 방법

    - <img src="assets/image-20230420190818559.png" alt="image-20230420190818559" style="zoom: 50%;" />
    - 과정
      1. 코드 커밋
      2. 통합 서버가 코드 커밋을 감지하고 빌드환경에 코드 다운로드
      3. 코드 컴파일 및 통합
      4. 빌드
      5. 테스트 : pull request 등
      6. 결과를 개발자에게 다시 전달(이메일, slack 등)
    - 장점
      - 결함의 조기 발견으로 인한 비용감소
      - 위험 감소
      - 품질에 대한 자신감

  - CD(Continuous Delivery) : 시스템이 실제 운영환경에 릴리스 준비가 되어있는지를 확인

    - CD는 CI를 포함하는 개념임

    - <img src="assets/image-20230420191156588.png" alt="image-20230420191156588" style="zoom: 67%;" />

    - 과정

      1. CI의 결과물을 전송
      2. 테스트
      3. Staging : 실제 운영환경에서 문제가 없는지 확인
         - 실제 운영환경과 비슷한 환경에서 실행
      4. 배포 : 실제 사람이 배포해야함

    - CD에서의 테스트 

      - 테스트 피라미드
        - <img src="assets/image-20230420191852391.png" alt="image-20230420191852391" style="zoom: 67%;" />
        - Unit 테스트 : 각 컴포넌트가 의도한대로 동작하는지 테스트
          - 컴포넌트는 함수 정도의 크기

          - 각 컴포넌트가 의도하는 다른 컴포넌트는 가짜로 대체

        - Integration 테스트 : 통합 테스트
          - 시스템이 외부 환경과 통합이 문제 없는지의 의존성 테스트를 의미(데브옵스에서

        - E2E Test : End to End 테스트
          - UAT(User Acceptance Testing)과 같은 의미
          - 전체 시스템이 통합된 상태에서 사용자 관점에서 테스팅

      - 위로 올라갈수록 시간이 많이 걸리므로 테스트 케이스를 줄이기


    - 테스트 환경
    
      - (QA) Testing 환경 : QA팀이 테스트를 하기 위해 사용하는 통제된 환경
      - 복잡하고 시간이 걸리는 테스트 수행
      - Staging 환경 : 배포 전 최종 테스트 환경
      - 실제 운영 환경과 동일
        - Testing 환경에서 통과 된 것만 
      - 기능적 테스트 뿐만 아니라 비기능적(부하)테스트 수행
        - E2E 테스트 
    - Product 환경 : 실제 운영환경
    
      - 배포가 이루어짐

  - Continuous Deployment : 사람의 개입 없이 자동으로 배포

    - Continuous Delivery는 사람의 개입이 있어야함

- 배포 전략

  - zero down time 배포가 중요
  - Rolling Update : 기존 인프라에 구 서비스를 제공하는 서버를 하나씩 순차적으로 새로운 버전으로 대체하는 방식

    - 장점 
      - 롤백 가능
    - 단점
      - 구버전과 신버전 서비스가 혼재되는 시점이 존재
      - 새버전으로 배포 될 때 과부하 가능성 있음
  - Blue green : 2개의 동일한 운영 환경을 준비하여 동시에 교체하는 방법
    - 장점 : 구버전과 신버전이 혼재하는 시점 없음
      - 롤백이 쉬움
    - 단점 : 여분의 인프라 필요
  - Canary : 일부 서버에만 신버전을 적용하고 그 서버를 일부 사용자 그룹의 트래픽을 분산하도록하고, 문제가 없으면 확장 적용
    - 장점
      - 소수의 사용자에게만 배포되기 때문에 상대적으로 영향이 적음 : Blue Green 보다 적음
      - 롤백 쉬움
    - Capcity Testing 수행 



### 2.8. Scrum

- 스크럼 프로세스 개요

  - increment(증분) : 하나의 스프린트에서 나오는 산출물
    - 이전의 결과물에서 조금더 더해진 산출물이기 떄문에
    - 잠재적으로 출시 가능한 제품
  - 비전 : 프로젝트에 대한 방향성
    - 프로젝트를 통해서 달성하고자 하는 것에 대한 간결하면서도 명확한 대답
    - 모든 이해 관계자들이 공유해야함 : 간결하고 수분안에 이해될수 있도록 표현
    - 구성요소
      - 목표고객 : **누가** 제품을 구매하는가 
      - 필요성 : 고객이 **무엇**을 필요로 하는가
      - 가치전달 : **어떤점**이 고객에게 가치를 전달하여 구매하게 하는가
      - 차별성 : 고객이 다른 시장의 **다른** 제품보다 어떤점이 이 제품을 선호하게 하는가 

- 스크럼 역할

  - Product Owner
    - 하는 일 : 제품 백로그 관리
      - 고객이 원하는 바를 파악하여 이를 제품에 반영
      - 제품이 추구하는 방향(비전,로드맵)을 설정하고 고객이 가장 가치가 있는 제품을 빨리 전달 받을수 있도록 요구사항에 우선순위를 매김
      - 고객으로부터 피드백을 받아 제품에 반영
      - 개발 팀에게 고객의 니즈를 설명
  - Scrum Master : 스크럼 팀이 스크럼을 제대로 이해하고 수행할수 있도록 도움을 주는 역할
    - 스크럼 팀을 도와주는 리더
  - Team
    - 자기 조직화 : 팀원들이 외부의 명령이나 통제 없이 스프린트 목표를 달성하기 위한 최상의 방법을 결정
      - 계층화 없음 : 스크럼 마스터도 동일한 위치
    - Cross-functional : 외부의 도움 없이 스프린트의 목표에 도달할수 있는 팀이여야함
      - 다양한 배경과 지식을 가진 팀원으로 팀을 구성
    - 팀 전체의 성공과 팀 전체의 실패
    - 팀의 지속성(Continuity)

- 스크럼 이벤트

  - <img src="assets/image-20230420205137349.png" alt="image-20230420205137349" style="zoom: 33%;" />
    - 외우기

  1. 스프린트 계획 : 스프린트 목표 설정 회의
  2. 일일 스크럼 : 스프린트 동안 매일 회의하는것
     - 어제 했던 일, 오늘 할 일, 작업 수행중 문제 등 이슈 공유
     - 문제점이 프로젝트 후반에 갑자기 등장하는것을 막음
     - 15분 내외
     - 스텐드업 미팅이라고도 부름
  3. 스프린트 리뷰 : 스프린트 종료 후 피드백
     - 스크럼 팀 뿐만 아니라 이해 관련자들이 모두 참여
     - 구현된 기능을 보여주면서 데모 수행
     - 프로덕트 오너가 리뷰에서 도출된 피드백을 반영하여 제품 백로그 갱신
  4. Sprint Retrospective(스프린트 회고, 스프린트 레트로스펙티브): 스프린트 피드백
     - 스프린트 팀이 참여
     - 프로세스가 변화하는 비지니스 환경에 적응할수 있도록 회의

- 스크럼 산출물

  - Product backlog : 제품에 필요한 모든 것을 기술한 우선순위가 있는 업무 목록
    - 백로그 업무 항목(PBI , Product Backlog Item) (기억해두기)
      - 기능 : 포인트 조회 기능
      - 비기능 : 저자명을 이용하여 1분이내에 받아볼수 있어야 한다(성능)
      - 오류수정
      - 지식습득(spike) : 스프린트중 기술적 지식 습득

    - 특성 : DEEP(ㅈㄴ 중요함)

      - Detailed appropriately(적절한 세부사항) : 우선순위에 따라 상세화 해야함

        - 가까운것을 더 상세하게 분할하고 상세화함

        - 모든 PBI가 똑같은 수준으로 상세화되는 것이 아님

      - Emergent(창발적, 발생적) : PBI와 그 우선순위의 변경이 자연스러움

        - 제품 책임자가 피드백을 바탕으로 PBI 업데이트

      - Estimated(추정) : 각 PBI는 추정치를 가지고 있어야함

        - 우선순위가 높은 PBI가 크기가 크다면 분할해야함
        - 스토리포인트나 시간을 사용해서 추정
          - 스토리 포인트 : 사용자 스토리의 규모를 표현하는 상대적 단위
            - 같은 프로젝트 안에서만 비교 가능
            - 스토리 포인트 추정 : Planning Poker 게임
              - 사용자 스토리에 대해서 숫자 카드로 의견을 제시하여 조율
            - 13 이상이면 분할할 필요 있음
            - epic : 한 스프린트동안 해결하지 못할수도 있는 스토리

      - Prioritized(우선 순위) : 

        - MosCow
          - M (Must) : 필수적인 기능, 제품으로서 존재 가치
          - S (Should have) : 중요하고 유용한 기능, 가능하다면 포함되어야함
          - C (Could have) : 사용자의 만족도를 올릴수 있지만 필수적인 것은 아님
          - W (Wont have ) : 현재 개발 일정에서 누락되어도 상관없음
        - 우선순위에 고려되어야 하는것
          - 비지니스와 고객에게 높은 가치
          - 구현하기 쉬운것
          - 리스크가 높은것(판단을 일찍)
          - 갈수록 비용이 높아지는것
          - 의존성이 높은것
          - 스프린트 목표와 연관성이 높은것
        - 모든 PBI에 대해서 우선순위를 매기려고 하지 않아도됨 : 가까운것만

    - 사용자 스토리(User Story) : 애자일에서 많이 사용하는 사용자 요구 사항 표기 방식
      - <img src="assets/image-20230420205500529.png" alt="image-20230420205500529" style="zoom:33%;" />
      - 3자기 구성요소
        - who
        - what
        - why
      - 사용자 관점에서 기술
      - 스토리는 고객이나 개발자 모두 이해 할 수 있도록 고객이 작성
        - 고객을 대신해서 프로덕트 오너가 대신 작성 , 스크럼 마스터가 도움을 줌
      - 사용자 스토리의 3가지 측면(3Cs)
        - Card : 카드에 들어갈 정도로 간결하게 작성
          - 대화를 위한 매개체
        - Conversation : 세부사항은 대화를 통해서 구체화
          - 전통적 개발 방식의 단점 파쇄
            - 문서화 되어 있기 때문에 각 인원이 서로 다르게 생각 할 수 있음
            - 모든 요구사항들은 같은 수준으로 상세화 해야함
          - shared understanding
          - 전통적인 방식은 모든 요구사항을 처음부터 상세하게 적시해놓아야 하는것과 대조
        - Confirmation(테스트) : 스토리의 완료 여부를 판단
          - acceptance criteria(억셉턴스 크리타이라, 인수기준) : 사용자 스토리가 완료(기능 동작)됬다고 생각할수 있는 기준
      - INVEST : 사용자 스토리를 구성하는데 유념해야할 조건 (중요)
        - Independent(독립적) : 사용자 스토리간의 의존성이 적어야함
          - 의존성이 많은 사용자 스토리는 개발 우선순위를 설정 하는 작업을 복잡하게 함
          - 의존성 있는 스토리를 하나로 묶는등의 작업을 해야함
        - Negotiable(협상 가능) : 상세한 사항은 협상이 가능해야함
          - 사용자 스토리에는 대화가 포함되기 때문
          - 협상 불가능한 스토리는 What이 고정되는 경우가 많음
            - 로그인 하고 하고싶다 -> 얼굴인식을 통해 로그인 
        - Valueable(가치있는) : 고객과 사용자에게 가치를 주어야함
          - 모든 사용자 스토리는 가치를 가져야함(I,N은 허용될수 있지만)
        - Estimable(추정가능한) : 필요한 노력과 비용을 추정할 수 있어야함
          - 너무 큰 스토리(epic)은 분할해야함
            - 예) 직업을 탐색하는 기능을 원함 -> 키워드로 작업 탐색 + 로케이션으로 직업 탐색
        - Small(작은) : 사용자 스토리는 알맞은 크기여야함
          - Just in time
          - 다음 스프린터에서 개발될 사용자 스토리는 최소한 스프린트 내에 개발 할 수 있는 크기로 분할
          - 먼 사용자 스토리는 당장 분할하지 않아도 됨
        - Test(테스트 가능한) : 스토리의 완성 여부를 판단 할 수 있어야함

    - Backlog refinement meeting 

      - 하는일
        - 에픽을 보다 작은 사용자 스토리로 분할하고, 분할된 사용자 스토리들에 대한 스토리 포인트 추정
        - 새로운 사용자 스토리에 대한 크기 추정
        - 다음에 다가올 스프린트에 대한 스토리 정제
        - 기존의 사용자 스토리 재추정
        - 우선순위 조정
      - 정제, 구체화 : 대화를 통해 구체화하고 인수기준 만들기
      - 스크럼 이벤트에는 포함되지 않음
      - 스프린트의 10%정도 사용
      - Definition of Ready(DoR) : 팀마다 다를 수 있음
        - 가치가 명확하게 기술
        - 의존 사항이 모두 식별
        - 인수기준이 명확하며 테스트 가능
        - PBI가 스프린트 내에 완성될수 있을 정도로 작게 추정됨

  - Spring backlog

    - 스프린트 계획 회의
      - 스프린트 목표 달성을 위해 해야할 일을 우선순위에 따라 제품백로그에서 가져옴
      - 제품 백로그를 테스크로 분할
      - 구성
        - 무엇을할지
          - 참가자 : 제품 책임자, 팀, 스크럼마스터
          - 하는일
            - 스프린터 목표 설정
            - 백로그 검토
        - 어떻게 할지
          - 참가자 : 제품책임자(선택) , 팀, 스크럼 마스터
          - 하는일
            - 팀이 스프린트 내에 할수 있는 아이템 선정
            - 아이템(스토리)를 테스크로 분할
              - 테스크 마다 책임자를 선정
            - 작업량 추정
      - 테스크 분할 
        - ![image-20230422212930910](assets/image-20230422212930910.png)
      - 백로그를 가져오는 기준
        - Capacity : 한 스프린트 동안 사용할수 있는 가용 시간
        - 각 팀원의 가용 시간을 파악 : 오직 프로젝트에 관련된 일만 할수 있는 시간 
          - 스프린트 계획 회의, 일일 스크럼 미팅, 이메일 등 제외
        - 테스크를 분할하고 테스크의 완료에 걸리는 시간을 팀원이 같이 추정
        - 가용시간이 넘지 않을 떄 까지 사용자 스토리 추가 : self organizing

  - increment

- 속도와 릴리스 계획

  - 속도
    - 속도의 정의(중요) : 한 스프린트 동안 완료된 스토리 포인트들의 합
      - 완전히 완료되어야함 : DoD 만족

    - 완료의 정의 : Definition of Done(DoD) : 반드시 기억
      1. Unit Tests 통과
      2. 코드 리뷰
      3. 리그레션 테스팅 통과
      4. 기능 테스팅 통과
      5. 인수 기준 만족 : 사용자 스토리마다 따로 적용
      6. 사용자 문서 갱신
      7. 성능 테스팅 통과
      8. UX 디자이너 승인
      9. 제품 책임자 승인

    - Velocity Charts : 속도를 추정할수 있는 차트
    - 불확실성을 고려한 속도 추정
      - 최소 보정치와 최대 보정치를 이용해서 속도의 범위 추정
      - 스프린트가 반복될수록 보정치의 범위가 줄어들음

  - 릴리스 계획
    - 속도를 이용해서 Scope를 결정
    - time 과  resorurces 를 고정
    - 추정치 : 속도가 20으로 추정되는 팀의 2달 프로젝트
      - 추정
        - 0.6 * 20 * 4 = 48 
        - 1.6 * 20 * 4 = 128

      - 48이상은 만들수 있음
      - 128이하는 만들어질 수도 있음

    - scope가 추정치 사이에 있는 경우 : 개발을 진행하고 개발에서 획득한 지식을 바탕으로 개발 진행 여부를 결정
      - 릴리스 날짜 연기
      - 개발 인력 추가
      - technical debts(기억) : 해야할 일을 안하거나 소홀히 함

    - scope가 추정치를 넘어서는 경우 
      - 개발중단
      - 릴리스 날짜 연기
      - 개발인력 추가
      - technical debts


## 3. 요구사항

### 3.1. 요구사항

#### 요구사항 개요

- 요구사항(Requirements) : 문제를 해결하기 위해 무엇을 구현해야 하는 가에 대한 명세
  - 시스템이 동작하는 방법이나 속성 혹은 특성을 설명
  - 시스템 개발 프로세스의 제약 조건으로 볼 수 있음

#### 요구사항 분류

- 비지니스 요구사항 : 해당 조직에서 프로젝트를 수행하여 시스템을 구현하는 이유

  - vison and scope document에서 많이 기술
    - vison : 프로젝트를 통해서 우리가 달성하고자 하는 것에 대한 간결하면서도 명확한 대답
      - 모든 이해 관계자들의 의사 결정 기반과 프로젝트 방향성 제공
      - 구성요소
        - 목표고객 : **누가** 제품을 구매하는가
        - 필요성 : 고객이 **무엇**을 필요로 하는가
        - **가치전달 : 어떤점**이 고객에게 가치를 전달하여 구매하게 하는가
        - 차별성 : 고객이 다른 시장의 **다른** 제품보다 어떤점이 이 제품을 선호하게 하는가
    - scope
      - 비지니스 요구사항을 만족할수 있는지에 따라 범위 결정
      - 기능 추가를 원하는 경우 제안된 변경이 비지니스 목표를 달성하는데 어떤 도움을 되는지 판별
      - Scope creep 예방 : 고객이나 이해관계자로부터 프로젝트 본래의 목적과는 관련이 없는 기능들이 예산이나, 기간 자원 등을 조정없이 계속 추가하는 현상
      - 범위 모델링 
        - Context Diagram : 시스템이 외부 환경에서 어떤 위치에 있는지 배경을 나타냄
          - <img src="assets/image-20230422221413757.png" alt="image-20230422221413757" style="zoom: 33%;" />
          - 가운데 원 = 프로세스 : 개발하고자 하는 시스템
          - 사각형 = Terminal / Terminator : 시스템 외부
          - 화살표 : data flow
        - 유스케이스 다이어그램
          - 배경도는 시스템 내부를 보여주지 않는 반면 유스케이스는 시스템 내부를 보여줌
          - 배경도는 터미널과 시스템 사이의 정보를 보여주지만 유스케이스는 액터와 유스케이스 사이의 정보를 보여주지 않음(data flow)

- Stakeholder requirement : 사용자가 가치를 제공 받기 위해 시스템을 통해 달성하고자 하는 목표나 수행하는 tasks

  - 식사 주문 , 메뉴 생성 , 급여 공제 등록 등

  - 비지니스 분석가/사용자/제품관리자로부터 비지니스 요구사항을 달성하기 위한 요구사항을 도출
    - 비지니스 요구사항으로 부터 도출

- 기능적 요구사항 : 사용자 요구사항을 달성할 수 있도록 개발자가 구현하는 것

  - 예 : 고객이 급여공제에 등록되어 있는지 확인, 결제 금액 계산 등

- 비기능적 요구사항 : 시스템이 제공하는 기능이나 서비스에 대한 제약

  - <img src="assets/image-20230422221704649.png" alt="image-20230422221704649" style="zoom: 33%;" />
  - 분류
    - 제품요구사항 : 품질 속성(기능이 얼마나 잘 돌아가는지 , 성능)
      - Usability(사용성) : 사용자가 소프트웨어를 얼마나 쉽게 사용할수 있을지
      - Efficiency(효율성) : 성능 및 공간(메모리 : 파일 크기 등)
      - Reliability(신뢰성) : 지정된 기간 동안 정의된 환경에서 의도된 기능을 고장없이 작동할 확률
      - Availability(가용성) : 주어진 시점에서 요청된 서비스가 제공되고 있을 확률
      - Portability(이식성) : 다른 종류의 운영체제나 시스템에 이식하는것과 관련된 요구사항
      - 이 외에도 여러 품질 속성이 있음
    - 조직요구사항(Organizational requirements) : 소프트웨어 개발 조직에 대한 요구사항
      - Delivery requirements (배포 요구사항) : 언제 어떤 형식으로 배포할 것인지에 대한 요구사항
      - Implementation requirements(구현 요구사항): 설계 및 구현에 대한 요구사항
        - 개발 언어, 프레임 워크, 데이터베이스 등
      - Standard requirements(표준 요구사항): 개발할 때 따라야할 표준에 대한 요구사항
    - 외부요구사항(External requirements) : 소프트웨어 개발에 영향을 미치는 외부에 관한 요구사항
      - Interoperability requirement(상호 운용성 요구 사항) : 구현할 소프트웨어가 다른 소프트웨어와 어떻게 연동할지를 정의하기 위한 요구 사항
      - Ethical requirement(윤리적 요구 사항) : 소프트웨어의 내용의 윤리적인 범위를 정하기 위한 요구 사항
      - legislative requirement(법적 요구 사항) : 소프트웨어가 법적으로 허용되는 범위 내에서만 작동함을 보장하기 위한요구 사항
        - privacy : 법적
        - safety : 안정성
  - 품질에서
    - 신뢰성
      - MTBF(Mean Time Between Failures) : 장애와 장애 사이의 기간
        - 정의 : 전체 가동 시간 / 장애 발생 수
      - Failure rate : 단위시간동안의 고장 수
        - 1 / MTBF
    - 가용성 = 운영시간 / 전체시간 = MTTF/MTBF
      - MTTF(Mean Time To Failure) = 운영시간
      - MTTR(Mean Time To Repair

#### 요구사항 개발 프로세스

- 프로세스
  1. 도출 : 요구사항 찾아내기
  2. 분석 : 요구사항을 자세하고 정확하게 이해
  3. 명세 : 문서화
  4. 검증 : 요구사항이 정확하게 작성되었는지 검증

### 3.2. 요구사항 도출 

- 인터뷰 : 직접 대화

  - 친밀감

  - 범위에서 벗어나지 안히

  - 폐쇄적인 질문(yes no)보다 개방향 질문

  - 5 whys 기법을 활용하여 문제의 근본 원인 식별
    - 근본 원인을 찾을때까지 why

- 워크샵 : 다양한 이해관계자들을 모아서 협의를 통해 요구사항 도출

  - Facilitator(촉진자) : 회의진행

  - 특정 주제 기반의 의견 공유

  - 다양한 이해관계자의 요구사항을 동시에 도출

  - 의견 충돌을 해소하고 가능한 한 빨리 합의에 도달 가능

  - 정해진 시간안에 집약적인 의견 교환 가능

- 관찰 :업무 환경에서 사용자의 work flow 를 관찰하여 현 시스템의 문제점을 식별 하고 더 나은 방법 파악

  - 적극적 관찰 : 업무중에 질문등을 통해 이유를 바로 이해
  - 수동적 관찰 : 업무를 방해햐지 않고 관찰

- 설문 : 대규모 사용자 그룹의 요구를 이해하기 위한 조사 방법

  - 상용 제품에 대한 피드백
  - 가장 문제가 되는 영역을 파악할 때
  - 우선 순위 결정돠 같은 정량적 데이터의 제시가 필요할 때

- 브레인스토밍 : 짧은시간 안에 소수의 그룹이 최대한 많은 아이디어를 이끌어내기 위한 방법

  - 4s 원칙
    - 비판금지(Support)
    - 자유분방(Silly) : 개소리도 아이디어로
    - 양산(Speed) : 양치기
    - 결합과 개선(Synergy) : 모든 아이디어를 기록하고 결합과 개선을 통해 제 3의 아이디어를 이끌어내기

- 문서 분석 : 사업계획서, 기술 문서, 문제점 보고서 등 문서를 검토

  - 기존 시스템이나 신규 시스템에 대한 정보 습득
  - 시스템 교체 프로젝트인 경우 더 이상 필요 없는 기능 뿐만 아니라 계속 유지해야 하는 기능 식별
  - 문제 보고서나 개선 요구서는 시스템이 추후 제공할 아이디어 제공

### 3.3. 요구사항 분석

- 불완전하고 추상적인 요구사항을 적절한 수준으로 분해하고 정제
- 고객과의 상호 작용을 통해 혼동지점을 명확히 하고 요구사항의 중요도 파악
- 명세를 만들기 위한 기반
- 모델링을 통해 구체화 하고 가시화 해서 이해도 향상
  - 구조적 분석(자료 흐름도 , DFD) : 배경도와 비슷하지만 더 많은 정보 포함
    - <img src="assets/image-20230330210123116.png" alt="image-20230330210123116" style="zoom:33%;" />
    - <img src="assets/image-20230422222741484.png" alt="image-20230422222741484" style="zoom:50%;" />
    - 프로세스 : 시스템이 제공해야하는 가능
    - 터미널 : 시스템 외부 객체
    - 배경도와 다르게 내부의 구조도 보여줌
      - 배경도는 범위만
    - 기능 분할 : 프로세스를 분할
    - 기능위주로 분석
  - 유스케이스 분석 모델링
    - 사용자 관점에서 분석 : 왜 시스템을 사용하는지
      - 범위도 나타내지만 사용자의 요구사항에 집중
  - 사용자 스토리 사용(애자일 프로젝트)
  - ERD(개체 관계도) : 데이터의 구성과 관계
    - Entity Relation
  - State Transition Diagram
  - Dialogue Map

### 3.4. 유스케이스 모델링

- 시스템을 사용하는 목적(유스케이스)를 표현
  - 목적 달성을 위한 사용자와 시스템 사이의 상호작용 표현
- 시스템이 제공하는 서비스를 정의하고 시스템의 범위를 결정

#### 구성요소

- Actor : 시스템의 외부에 있으면서 시스템과 상호작용하는 사람 또는 또 다른 시스템
  - 엑터명을 기술
  - 실체 객체가 아닌 그들이 수행하는 역할
  - 시스템인 경우 박스로 나타내고 <\<actor>> 로 표시
  - primary actor : 시스템을 사용함으로써 실제 가치를 획득하는 액터
    - 왼쪽에 그리는것이 관례
  - secondary actor : 주 액터의 목적 달성을 위해 지원하는 액터
    - 오른쪽에 그리는것이 관례
- Usecase : 시스템이 액터에게 제공해야하는 기능
  - 시스템의 요구사항을 보여줌 : 액터가 시스템을 사용하는 목적으로도 기술 가능
  - ~한다와 같이 동사로 표현
- System
  - 만들고자 하는 애플리케이션
  - 박스 바깥은 구현할 시스템의 외부
- Relationship : 액터와 유스케이스 사이의 의미 있는 관계
  - association(연관 관계)
    - 유스케이스와 상호작용이 있음을 표현
    - 실선
  - dependency(의존 관계)
    - include(포함 관계) : 특정 유스케이스가 다른 유스케이스의 선행을 필요로 할때
      - ![image-20230422223327310](assets/image-20230422223327310.png)
      - 화살표가 가르키는 방향이 필요한 유스케이스
        - 글을 등록한다 -> 로그인을 한다
      - <\<include>> 라고 표기
    - extend(확장 관계) : 특정 조건에 따라서 기능을 확장 가능
      - ![image-20230422223402033](assets/image-20230422223402033.png)
      - 화살표가 가르키는 방향이 기본기능 유스케이스
        - 글을 등록한다 <- 파일을 첨부한다
      - <\<exclude>> 라고 표기
  - generalization(일반화 관계) : 유스케이스 들에게 추상화 할수 있는 일반화 관계가 있을때 사용
    - ![image-20230422223538169](assets/image-20230422223538169.png)
    - 엑터에서도 사용 가능
    - 화살표가 가르키는 방향이 추상적인 유스케이스
      - 글을 검색한다 <- 글쓴이로 검색한다

#### 작성순서

1. 시스템 식별 : 만들고자 하는 시스템은 게시판
2. 액터식별 : 게시판 외부에서 상호작용하는 액터로 글을 등록하고 삭제하는 등의 역할을 하는 사용자 식별
   - 누가 정보를 제공하고, 사용하고, 삭제하는지
   - 누가 사용하는지
   - 누가 시스템에 관심을가지는지
   - 누가 유지보수 및 관리를 하는지
   - 상호작용하는 외부 시스템이 무엇인지
3. 유스케이스 식별
   - 액터가 원하는 시스템 기능은 무엇인지
   - 액터가 어떤 정보를 다루고 싶어하는지
   - 시스템이 어떤 기능을 제공하면 액터에게 도움이 되는지
4. 관계 정의

#### 유스케이스 명세서 작성

- 유스케이스로 표현된 목적을 달성하기 위한 시스템과 상화작용하는 단계를 기술

- <img src="assets/image-20230422224112175.png" alt="image-20230422224112175" style="zoom:50%;" />
  - 대체 흐름 : 단계번호+문자 로 표기: 7a.

  - <img src="assets/image-20230422225137271.png" alt="image-20230422225137271" style="zoom: 50%;" />
    - 다른 유스케이스에서 반복되는 것은 "로그인" 유스케이스로 만듬
    - {파일첨부} : 확장점
  - 관계를 고려한 유스케이스 다이어그램 해석
    - 시스템 S , 액터 A, 유스케이스 U
      - A가 U와 연관 : A는 U를 달성하기 위해 S와 상호작용
      - U1이 U2의 포함관계 : U1을 하기 위해 U2를 반드시 수행
      - U2가 U1의 확장관계 : U1에서 경우에 따라 U2수행
      - U가 U1 , U2 ,U3의 일반화 관계 : U의 종류로 U1 , U2, U3 이있다

### 3.5. 요구사항 명세

- 요구사항 명세 : 요구사항을 명확하고 완전하게 기록하는 것
- 최종 결과물 : 요구사항 명세서(SRS : Software Requirement Specification )

#### 좋은 요구사항 명세를 작성하기 위한 특성

- Necessary : 필요한 요구사항만 있어야함
  - Gold plating 방지 : 고객이 요구하지 않았는데 개발자가 부수적이나 장식적인 기능을 추가하는것
  - 상위 요구사항을 만족시키는 요구사항인지 확인하기
    - 사용자 요구사항 : 신규가입자는 할인 혜택을 받을수 있다
      - 기능적 요구사항 : 7일이내 가입자에게 할인쿠폰 발생 -> OK
      - 기능적 요구사항 : 최근 60일 내에 구매 실적이 없는 기존 가입자에게 이메일로 할인 정보 전송 -> NO
- Implementation Free : 요구사항에 불필요한 설계 및 구현 정보가 포함되지 않아야함
  - 제약이 될 수 있음
  - 예 : 토핑 옆에 있는 체크박스를 선택하여 베이글에 추가 할 수 있음
- Unambiguous : 요구 사항이 애매모호하면 안됨
  - 예 : 시스템은 출발지에서 목적지 까지 가장 좋은 길을 찾을 수 있어야 한다
- Complete : 각 요구사항을 이해하는데 필요한 모든 정보를 가지고 있어야 하고, 발생할 수 있는 모든 조건에 대해 기술해야함
  - 예 : 교수는 사용자 id, 비번 및 관련된 정보를 이용하여 시스템에 로그온 할 수 있어야 한다.
    - 정보가 완전하지 않음
  - 예 : 프리미엄 약정이 선택되지 않고 보험 증명이 제공되지 않으면 사용자에게 기본 약정이 자동으로 선택되어야 한다
    - 발생 할수 있는 모든 가능성에 대해서 기술하지 않음 : 프리미엄 약정 x , 보험 증명 o
- Atomic : 각 요구사항이 여러 요구사항으로 분리되지 않아야함(원자적이어야함)
  - 예 : 시스템은 항공권 예약, 항공권 구매, 호텔 객실 예약, 자동차 예약, 명소 정보 제공의 기회를 제공해야 한다.
    - 각 기능을 분리해야함
- Feasible(실현가능성) : 비용, 일정, 기술 등과 같은 제약 내에서 실행 가능해야함
- Traceable : 요구사항은 요구사항의 출처 및 요구사항으로부터 파생된 다른 시스템 구성요소(설계, 코드 , 테스트 케이스)등과 연결되어야 함
  - 특정 기능적 요구사항이 어떤 사용자 요구사항으로부터 파생되었는지 파악 가능해야함
  - 특정 기능적 요구사항과 기능 또는 설계등이 연결되어야함
  - RTM(Requirements Traceability Matrix) : 테스트 케이스와 함께 사용자 요구사항을 매핑하고 추적하는 문서
    - <img src="assets/image-20230406202158131.png" alt="image20230406202158131" style="zoom:33%;" />
- Verifiable : 요구사항이 검증 가능해야함
  - 예 : 시스템은 모든 페이지를 받아드릴수 있는 범위 내에서 로드하여함
    - 모든 페이지의 범위가 명세되어있지 않음
  - 품질속성템플릿 : 품질을 검증할때 속성들
    - Source(소스) : 자극을 생성하는 개체
      - ATM 사용자
    - Stimulus(자극) : 시스템에 영향을 주는 조건
      - 계좌이체
    - artifact(대상 또는 산출물) : 자극에 의해 영향 받는 시스템(부분)
      - ATM
    - 환경 : 자극이 발생된 상황
      - 평일 9 ~ 5
    - responce(반응) : 자극으로 야기되는 시스템 행위
      - 계좌이체 완료
    - measure(반응 척도) : 시스템 반응을 평가하는 척도
      - 걸리는 시간 : 2초 등
- Consistent(일관성) : 다른 요구사항과 모순이 없어야 하며 동일한 개념을 다른 용어로 기술하지 않아야함
- NonRedundant(중복되지 않음) : 각 요구사항은 다른 요구사항과 중복되지 않고 한번만 기술되어야함
  - 예 :
    - 비행기 날짜 예매시 날짜를 입력할때 달력을 이용해야함
    - 시스템에서 날짜 입력시 달력을 이용해야함

#### 소프트웨어 요구사항 명세서 국제 표준

- <img src="assets/image-20230406204008818.png" alt="image-20230406204008818" style="zoom:50%;" />
- 기술
  - TBD(To Be Determined) : 추후 결정하여 작성
  - N/A(Not Applicable) : 해당 사항이 없음
  - None : 해당 사항이 있지만 하지 않는다
- 목차
  1. Introduction(소개)
     1. Purpose : 무엇을 위해 이 문서를 작성 했는지 설명
        - 제품의 용도 나열 x
        - 예 : <img src="assets/image-20230406204038182.png" alt="image20230406204038182" style="zoom:33%;" /> 
     2. Scope : 개발할 소프트웨어에 대한 설명
        - 개발 범위에 대한 명세
        - 소프트웨어에 대한 핵심을 얻을수 있음
        - 단순히 기능을 나열하는것이 아님
        - 필요하다면 비전과 범위 문서 참조
  2. Overall Description(개략적인 설명)
     1. Product Perspective(제품 조망) : 제품을 외부에서 바라본 모습 설명
        - 신규, 기존제품 대치, 차기 버전 등 적시
        - 큰 시스템의 일부라면 큰 시스템과의 인터페이스 기술
        - 배경도와 같은 다이어그램으로 외부와의 관계 기술 가능
     2. Product Functions(기능) : 제품이 가지고 있는 주요 기능을 개략적으로 설명
        1. 항목식으로 기술
     3. User Characteristic(사용자 특성) : 제품의 예상 사용자를 식별하고 특징 기술
     4. Constraints(제약사항) : 반드시 사용하거나 피해야하는 특정 기술을 명세
        - 표준, 웹 브라우저 유형, 데이터 베이스 등
     5. Assumption and Dependencies(가정 및 의존성) : 프로젝트를 수행하기 위한 전제 조건 또는 선행되어야 할 사항 명세
        - 가정에 문제가 생긴다면 프로젝트가 위험해짐
        - 변화에 대한 우회 방법을 기술함
        - 예) M사의 N라이브러리가 10월 30일 까지 출시
  3. specific requirements (특정 요구 사항)
     1. 외부 인터페이스 요구사항
        - 분류
          - 사용자 인터페이스 : 프로젝트가 따는 UI 표준과 가이드
            - 웹 적합성 : 모든 사용자가 신체적, 환경적 조건에 관계 없이 웹에 접근하여 이용할 수 있도록 보장
            - 웹 호환성 : OS , 브라우저와 상관 없이 유사한 화면으로 동일한 접근이 가능
            - 도움말 버튼과 같이 모든 화면에 나타나는 표준 버튼이나 기능, 탐색 링크
            - <img src="assets/image-20230406205826151.png" alt="image20230406205826151" style="zoom:33%;" />
            - 참고 : 전자정부 웹사이트 가이드라인
          - 하드웨어 인터페이스
            - 외부 하드웨어 장비 유형
            - 소프트웨어와 하드웨어간의 상호 작용
          - 소프트웨어 인터페이스 : 데이터베이스, 외부 라이브러리, 도구, 운영체제, 외부 소프트웨어와 통신 등에 관한 인터페이스 기술
            - PPT 참고
          - 커뮤니케이션 인터페이스 : 전자 우편, 웹브라우저, 네트워크 서버 통신 프로토콜 등 통신과 관련된 요구사항
            - 통신 보안, 암호화 문제, 데이터 전송 속도 등을 기술
            - HTTP 프로토콜을 사용하며, 80포트가 방화벽에서 열려있어야함 등
     2. Functions : 상세한 기능적 요구사항
        - 2.2절에서 언급한 기능을 상세하기 기술하거나 사용자 요구사항으로부터 추출된 기능적 요구사항을 매우 상세하게 기술
     3. Performance Requirements : 성능 요구사항
     4. Logical Database Requirements : 데이터 항목 및 데이터 간의 논리적 관계를 모델링
        - ERD 등 사용
     5. Software System Attributes : 보안성, 신뢰성, 가용성 등과 같은 품질에 대한 요구사항 기술



### 3.6. 요구사항 검증

- 테스팅
  - 정적 테스팅 : 프로그램 실행 x
    - 문서들을 대상으로 개발 초기 단계에 사용하여 오류 예방 가능
    - 리뷰 : 도구 사용 x
    - 정적분석 : 도구 사용 o
      - 결함이 아닌데 결합으로 판단할 가능성이 있어서 수작업이 한번 필요
  - 동적 테스팅 : 프로그램 실행 o
    - 코드를 검증

#### 리뷰

- 동적테스트와 달리 프로그램 직접 수행 X
- 동료와의 협동 작업을 통한 작업 결과물 검토
  - 동료검토 = peer review
- 목적
  - 오류 검출
  - 표준 부합 여부 판단
  - 대상물 개선
  - 새로운 기술 및 방법에 대한 정보 교류 및 교육
- 대상
  - 요구사항명세서
  - ui 설계/아키텍처/구조설계/상세설계
  - 코드
  - 테스트 계획서/테스트 케이스/테스트 절차
  - 프로젝트 계획 문서 등
- 리뷰 VS 동적 테스팅
  - 리뷰
    - 이해용이성, 유지보수성과 같은 품질 특성 테스팅에 용이
    - 동료 검토를 통해 직접적인 원인 탐색 가능
    - 프로그램 결함 때문에 동적테스트로는 진행하지 못하는 테스팅도 가능
  - 동적 테스트
    - 오류의 직접적인 원인을 찾지 않음
- 분류 : IEEE-1028 표준에서 분류
  - inspection : 참가자의 역할이 정해져있고 미리 계획되어져 있는 가장 형식적인 검토 방법
  - Technical Review
  - Walkthrough
  - Management Review
  - Audit



#### Inspection

- 참가자의 역할이 정해져있고 미리 계획되어져 있는 가장 형식적인 검토 방법
- 참가자에게 역할 부여
  - 개발자(Author) : 검토 대상물을 작성한 사람
    - 요구사항 : SRS를 만든 사람 = 비지니스 분석가
    - 인스펙션 요구
    - 인스펙션에 필요한 자료 제출
    - 회의에서 질문에 대한 답변
    - 미팅에서 검출된 오류 수정
    - **주재자, 리더, 서기가 될수 없음**
  - 회의주재자(Moderator/Inspection Leader)
    - 인스펙션 일정 계획
    - 참가자 선정 및 역할 부여
    - 개발자와 인스펙션 패키지를 취합하여 참가자에게 미리 전달
    - 인스펙션 회의 주재
    - 재작업(rework)검증 또는 위임
    - 인스펙선 요약 보고서를 작성
  - 리더(Reader) : 회의에서 작업 대상물을 설명해주는 사람
    - 인스펙션 회의 동안에 작업 대상물 발표 : 자신의 이해를 바탕으로 모델 등을 이용
    - 질문,코멘트,문제 등을 이끌어 냄
    - 서기와 동일인일수 없음
  - 서기(Recorder/Scribe)
    - 인스펙션 회의동안에 제기된 모든 논쟁 및 질문 답변을 기록
    - issue log
  - 검토인(Inspector)
    - 인스펙션 회의를 위해 미리(준비 단계) 인스펙션 패키지를 검토
      - 체크리스트 사용
    - 인스펙션 회의 때 문제 발견 및 개선책 등을 제시
  - 검증인(Verifier) : 올바르게 수정됬는지 확인
    - 인스펙션 회의에서 발견된 모든 결함들을 제대로 수정하였는지 확인
      - follow up 단계
    - 수정이 안된 결함이 있으면 왜 수정을 안 했는지에 대한 결정이 올바른지를 확인
    - 제기된 개선책이 구현되었는지 확인
    - 인스펙선 회의때 논의되지 않았던 사항을 임의대로 추가 및 변경하였는지 확인
    - 최종 결과물이 형상 관리 시스템에 제공되었는지 확인
- 적은 부분을 여러사람이서 검토 : 비용이 비쌈 -> 미리 계획
- 동적 테스트에 비해 비용이 적고 오류 검출률이 높음
- 참가자 선정
  - 기반 작업 결과물 개발자
  - 대상 결과물을 기반으로 작업하는 개발자 : 설계
  - 대상 결과물과 통신하는 작업물 개발자 : 인터페이싱
  - 여러 이해관계자 참여 가능
- 절차
  1. inspection planning
     - 인스펙션 횟수 및 일정을 계획하고 공지 : 주재자, 개발자
     - 작업물의 크기는 1~2시간안에 검토 될수 있는 크기
       - 코드 : 250줄
       - 명세서 : 3~5쪽
     - 참가자 선정 및 역할 부여 : 주재자
     - 개요 설명이 필요한지 결정 : 개발자
     - 인스펙션 패키지를 참가자들에게 전달 : 주재자, 개발자
  2. 개요 설명(선택적) : 검토 대상물 자체에 대한 이해가 목적
     - 30~60동안 개요 설명
  3. 개인 준비 : 검토인이 개인적으로 문서등을 검토
     - 작은 오류(철자 등)는 여기서 발견후 수정또는 전달 가능
     - 체크리스트 사용 가능
     - 주재자가 검토인에게 특정 목적에 따라 검토하도록 요구가능
  4. inpection meeting
     - 과정
       1. 준비상황 확인
          - 참가자 및 역할 소개
          - 인스펙션 목적 소개 : 평가 대상이 개발자가 아닌 결과물이라는 사실 주지
          - 해결책보다는 결함 식별에 중점이라는 사실 주지
          - 참가자들이 얼마나 많은 시간을 할애하여 준비하였는지 확인
            - 준비가 충분하지 못하다고 판단되는 회의 연기
            - entry critra : 회의 진행 기준
       2. 검토물 발표
       3. 결함/이슈 토론
          1. 기술적 해결 방안에 너무 많은 시간 할애 금지
       4. 이슈 기록
          1. 기록하기전에 확인 요청
       5. 평가
       6. 보고서 작성
  5. 수정(재작업) : 개발자가 수정
     1. 제기된 각 이슈에 대해 어떤 처리를 했는지 명시
        1. 수정하지 않은 이슈는 이유를 기록
     2. 관련된 문서도 함께 수정
  6. Follow-up : 확인
     - 이슈 로그에 있는 모든 결함의 처리가 이루어졌는지 확인
     - 수정되지 않은 이슈에 대한 개발자의 판단이 올바른지 판단
     - 수정된 결과물에 대한 재작업이 잘 이루어졌는지 검사
     - 최종결과물을 형상관리 시스템에 인도
     - 실제적 결함에 대한 통계 : 인스펙션 요약보고서에 반영



#### Walkthrogh

- 인스펙션보다 비형식적인 리뷰 방법
- 일반적으로 개발자가 회의를 주재함
- 개발자의 요청으로 이루어짐
- 참가자의 역할이 명확하게 구분되지 않을 수 있음
  - 주재자가 서기역할을 할 수 있음
- rework/follow-up이 요구되지 않음



#### 프로토타입

- 프로토타입 : 시스템의 일부 측명은 사용자가 경험할수 있게 해주는 도구
  - 요구사항 오류나 누락 식별
  - 요구사항 도출 도구로도 활용 가능
- 요구사항에 대한 대화 촉진
- 이해도 향상 가능
  - 종류
    - 범위
      - horizontal 프로토타입 : ui만 구현
        - 기능부분 구현 미비
        - 정해진 출력
        - 오류출력 미비
        - 요구사항 구체화. 누락 식별, 잘못되거나 불필요한 요구사항 확인, 대안 프로세스 탐색에서 활용
      - vertical 프로토타입 : 일부 ui와 일부 백앤드를 구현
        - 기술적 타당성 평가 목적으로 PoC(Proof of Concept : 개념증명) 구현
  - Fidelity(충실도) : 최종제품과 흡사한 정도(중료)
    - 요소
      - 외관
      - 콘텐츠
      - 상호소통
    - Low Fidelity
    - High Fidelity
  - 재사용성
    - Throwaway : 일회성
      - 빠른 구현과 수정을 강조
    - Evolutionary : 프로토타입을 기반으로 제품을 점진적 개발
      - 엄격한 개발과정 적용
- 요구사항 도출 방법
  - Paper Prototyping(Lo-Fi)
    - 사람이 사용자의 지시를 듣고 로직을 수행
    - 이를 통해서 요구사항 명세서 작성 가능
    - 누락된 요구사항 검출 

#### 테스트

- 요구사항은 테스트 케이스를 설계하는 기반
- 테스트 케이스를 설계할 때 예상하는 시스템 동작을 가시화
- 모호한 요구사항에 대해 테스트 케이스를 설계할 때 입력이나 출력이 모호할 수 있음
- 테스트와 테스트 케이스를 통해 요구사항 누락 확인가능
  - 다이얼로그 맵을 통한 시뮬레이션





## 4. 형상관리

- 형상관리 : 변경을 추적하고 통제하는것
- 요구사항 변경은 제품의 퀄리티를 위해 통제되어야함
  - Configuration Item(CI) : 공식적인 변경 관리 이루어져야하는 항목. 형상 항목
    - 산출물 거의 대부분
- 베이스라인 : 공식적인 변경 통제 절차에 의해서만 변경 될수 있는 상태
  - 형상 항목이 특정 시점에서 될 수 있음
  - 형상 항목들의 승인된 특정 버전들로 구성
  - 레퍼런스 포인트로 사용
  - 동일 베이스라인에 있는 형상 항목들은 일관성을 유지하여함
    - 코드가 그 버전의 SRS를 기반으로 이루어져야함
- 변경관리 프로세스
  - 변경 심사
    - CCB(Change Control Board) : 변경 심사를 하는 위원회
      - 프로젝트 관리자, 제품관리자, 마케팅, 비지니스 분석가, 개발자, QA 등으로 구성
      - 변경 영향 평가(인력이나, 비용, 기간 및 리스크 평가)을 수행하여 형상항목의 변경을 수락 또는 거절
  - 변경 실시
    - 체크아웃(Check-out): 형상 저장소에서 내가 작업할 컴퓨터로 변경할 항목을 가져오는 것
- 형상 관리 활동
  - 형상 식별 : CI를 선정하는 활동
    - 베이스 라인 기준 선정
  - 형상 상태 보고 : 베이스라인으로 설정된 형상 항목의 구조와 변경 상태를 기록하고 보고
    - 형상 항목의 개발 상태에 대한 가시성 제공
    - 베이스라인의 일관성 유지
  - 형상 감사 : 형상 관리 계획에 따라 형상 관리가 진행되고 있는지 감사
    - 기능적 형상 감사(Functional Configuration Audit, FCA) : 테스트케이스 결과 보고서 등을 검토하여 기능적으로 무결성 검증
    - 물리적 형상 감사(Physical Configuration Audit, PCA) : 일관성을 감사
      - 모든 문서 : 실제로 존재하고 시스템에 대해 정확하게 설명하는지 감사하며
      - 소스 코드 : 리포지토리에 유지 관리되었으며 배포된 기준선에 실행 파일을 반영하는지를 감사



## 대면강의 언급

- 11문제 정도
- 개발자가 테스트 이전에 해야하는것 -> 원격저장소와 동기화
- 고객의 요구사항을 빨리 반영할수 있도록 노력(lead time, waiting time)
  - leadtime을 짧게 가져가는것이 목적
- DepOps의 가장 중요한 두가지 요소
  - CI(Continueous Integration) : 지속적 통합
    - 코드를 하루에 몇번씩 통합
    - 단위 테스트
  - CD(Continueous Delivery , Deploment)
    - CD는 CI를 포함하는 개념
    - Docker 등 실행파일을 테스트 환경에 올리는 순간부터 CD
    - E2E 테스트 : CI의 영역이 아니고 CD의 영역
      - 도커 이미지(스테이징 환경)
        - 비 기능적 테스트도 함(Non Functional Test)
- 번다운 차트 : ppt의 작업 현황이랑 비교해보기
  - x축 : 스프린트 시간
    - 10day : 2주
  - y축 : 남은 작업 시간
  - 그래프가 위에 있으면 늦어지는 것
  - 그래프가 아래에 있으면 앞서가는 것
- 스크럼에서는 프로젝트가 늦어지면 범위를 줄이는것이 맞음
- low fidelity
  - 사용자 요구사항을 테스트하기 위한 목적등으로 많이 사용
  - paper protoyping
- 테스트
  - 동적 테스팅은 실제 프로그램의 동작을 테스팅 함
    - 따라서 문서 검증에서 사용할 수 없음
  - 정적테스팅
    - 리뷰
    - 정적분석 : 도구를 사용하지만 코드를 사용하진 않음
      - 문제가 아닌데도 문제인것처럼 리포트해주는 경우가 있음
        - 실제로 실행되어야 알수 있기 떄문에 실행 후 수작업으로 검사해야함

